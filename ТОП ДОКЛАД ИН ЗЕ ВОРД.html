<!DOCTYPE html>
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><!--metatextblock--><title>ТОП ДОКЛАД ИН ЗЕ ВОРД</title><meta name="description" content="ЭВЕР"><meta property="og:url" content="http://vonu4len0ski.tilda.ws"><meta property="og:title" content="ТОП ДОКЛАД ИН ЗЕ ВОРД"><meta property="og:description" content="ЭВЕР"><meta property="og:type" content="website"><meta property="og:image" content="https://static.tildacdn.com/tild6437-3334-4934-b864-636532653935/-/resize/504x/_cRwP0YLAbA.jpg"><link rel="canonical" href="http://vonu4len0ski.tilda.ws/"><!--/metatextblock--><meta property="fb:app_id" content="257953674358265"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://tilda.ws/"><link rel="dns-prefetch" href="https://static.tildacdn.com/"><meta name="robots" content="nofollow"><link rel="shortcut icon" href="https://faviconka.ru/ico/1/faviconka.ru_1_10430.ico" type="image/x-icon"><!-- Assets --><link rel="stylesheet" href="./ТОП ДОКЛАД ИН ЗЕ ВОРД_files/tilda-grid-3.0.min.css" type="text/css" media="all"><link rel="stylesheet" href="./ТОП ДОКЛАД ИН ЗЕ ВОРД_files/tilda-blocks-2.12.css" type="text/css" media="all"> <link rel="stylesheet" href="./ТОП ДОКЛАД ИН ЗЕ ВОРД_files/tilda-animation-1.0.min.css" type="text/css" media="all"><link rel="stylesheet" href="./ТОП ДОКЛАД ИН ЗЕ ВОРД_files/tilda-slds-1.4.min.css" type="text/css" media="all"><link rel="stylesheet" href="./ТОП ДОКЛАД ИН ЗЕ ВОРД_files/tilda-zoom-2.0.min.css" type="text/css" media="all"><script type="text/javascript" async="" id="tildastatscript" src="./ТОП ДОКЛАД ИН ЗЕ ВОРД_files/tildasimplestat-0.1.min.js.Без названия"></script><script src="./ТОП ДОКЛАД ИН ЗЕ ВОРД_files/jquery-1.10.2.min.js.Без названия"></script><script src="./ТОП ДОКЛАД ИН ЗЕ ВОРД_files/tilda-scripts-2.8.min.js.Без названия"></script><script src="./ТОП ДОКЛАД ИН ЗЕ ВОРД_files/tilda-blocks-2.7.js.Без названия"></script> <script src="./ТОП ДОКЛАД ИН ЗЕ ВОРД_files/lazyload-1.3.min.js.Без названия" charset="utf-8"></script><script src="./ТОП ДОКЛАД ИН ЗЕ ВОРД_files/tilda-animation-1.0.min.js.Без названия" charset="utf-8"></script><script src="./ТОП ДОКЛАД ИН ЗЕ ВОРД_files/tilda-slds-1.4.min.js.Без названия" charset="utf-8"></script><script src="./ТОП ДОКЛАД ИН ЗЕ ВОРД_files/hammer.min.js.Без названия" charset="utf-8"></script><script src="./ТОП ДОКЛАД ИН ЗЕ ВОРД_files/tilda-zoom-2.0.min.js.Без названия" charset="utf-8"></script><script type="text/javascript">window.dataLayer = window.dataLayer || [];</script><script type="text/javascript">if((/bot|google|yandex|baidu|bing|msn|duckduckbot|teoma|slurp|crawler|spider|robot|crawling|facebook/i.test(navigator.userAgent))===false && typeof(sessionStorage)!='undefined' && sessionStorage.getItem('visited')!=='y'){	var style=document.createElement('style');	style.type='text/css';	style.innerHTML='@media screen and (min-width: 980px) {.t-records {opacity: 0;}.t-records_animated {-webkit-transition: opacity ease-in-out .2s;-moz-transition: opacity ease-in-out .2s;-o-transition: opacity ease-in-out .2s;transition: opacity ease-in-out .2s;}.t-records.t-records_visible {opacity: 1;}}';	document.getElementsByTagName('head')[0].appendChild(style);	$(document).ready(function() {	$('.t-records').addClass('t-records_animated');	setTimeout(function(){ $('.t-records').addClass('t-records_visible'); sessionStorage.setItem('visited','y');	},400);	});
}</script><style type="text/css">@media screen and (min-width: 980px) {.t-records {opacity: 0;}.t-records_animated {-webkit-transition: opacity ease-in-out .2s;-moz-transition: opacity ease-in-out .2s;-o-transition: opacity ease-in-out .2s;transition: opacity ease-in-out .2s;}.t-records.t-records_visible {opacity: 1;}}</style></head><body class="t-body" style="margin: 0px;"><!--allrecords--><div id="allrecords" class="t-records t-records_animated t-records_visible" data-hook="blocks-collection-content-node" data-tilda-project-id="3687717" data-tilda-page-id="17340717" data-tilda-formskey="c987207fa7c61d60b1678f121277bdd7" data-tilda-lazy="yes"><div id="rec281292029" class="r t-rec t-rec_pb_0 r_showed r_anim" style="padding-bottom:0px; " data-record-type="18"><!-- cover --><div class="t-cover" id="recorddiv281292029" bgimgfield="img" style="height:100vh; background-image:url(&#39;https://autoreview.ru/images/Article/1664/Article_166448_860_575.jpg&#39;);"><div class="t-cover__filter" style="height:100vh;background-color:#000;filter: alpha(opacity:20); KHTMLOpacity: 0.20; MozOpacity: 0.20; opacity: 0.20;"></div><div class="t-container"> <div class="t-col t-col_12 "><div class="t-cover__wrapper t-valign_middle" style="height:100vh;"> <div class="t001 t-align_center"> <div class="t001__wrapper" data-hook-content="covercontent"> <div class="t001__title t-title t-title_xl" style="" field="title"><strong>Способы хранения данных в ОС Android</strong></div> <div class="t001__descr t-descr t-descr_xl t001__descr_center" style="" field="descr">Обзор возможностей для хранения данных в ОС Android. Использование файловой системы. Создание и управление локальными базами данных.</div> <span class="space"></span> </div> </div> </div> </div> </div> </div> </div><div id="rec281292030" class="r t-rec t-rec_pt_30 t-rec_pb_30 r_showed r_anim" style="padding-top:30px;padding-bottom:30px; " data-record-type="127"><!-- T119 --><div class="t119"><div class="t-container "> <div class="t-col t-col_8 t-prefix_2"><div class="t119__preface t-descr" style="opacity:0.70;" field="text"><p style="text-align: center;"><strong>Развитие Android OS</strong></p></div></div></div></div></div><div id="rec281292031" class="r t-rec t-rec_pt_0 t-rec_pb_0 r_showed r_anim" style="padding-top:0px;padding-bottom:0px; " data-record-type="106"><!-- T004 --><div class="t004"><div class="t-container "> <div class="t-col t-col_10 t-prefix_1"><div field="text" class="t-text t-text_md " style="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По данным 2017 года, в 87,5% проданных смартфонов использовалась Android OS. Всего несколько лет понадобилось этой инновационной мобильной платформе для того, чтобы занять место лидера на рынке смартфонов и планшетов.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Изначально, в 2005 году компания Android Inc. являлась обычным стартап-проектом и занималась разработкой программного обеспечения для мобильных телефонов. Известный уже в то время гигант компания Google, уже в июле того же года решила купить данный проект, заприметив в нем большие возможности и, в частности, возможность создать инновационную мобильную платформу. Так, стартап-проект попал под крыло компании Google и началась работа над созданием новой мобильной ОС. Создание мобильной операционной системы с открытым исходным кодом, а это в свою очередь очень важный фактор для успешной конкуренции. Система создавалась на базе ядра Linux. В ноябре 2007 года, аккурат после появление первого iPhone, новая мобильная платформа была представлена на суд общественности. Название Android осталось от имени стартапа. Уже через несколько дней на серверах появилась бета-версия Android SDK, которая позволяла сторонним разработчикам создавать свой софт.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Параллельно с этим шла работа по привлечению крупных телекоммуникационных компаний - операторов связи и производителей мобильных устройств. В ходе этого был создан целый альянс, который насчитывал 34 компании, задачей которого было улучшение мобильной платформы и создание устройств, которые будут работать на ее базе.</div></div></div></div></div><div id="rec281771902" class="r t-rec t-rec_pt_30 t-rec_pb_30 r_anim r_showed" style="padding-top:30px;padding-bottom:30px; " data-record-type="127"><!-- T119 --><div class="t119"><div class="t-container "> <div class="t-col t-col_8 t-prefix_2"><div class="t119__preface t-descr" style="opacity:0.70;" field="text"><p style="text-align: center;"><strong>Особенности ОС Андроид</strong></p></div></div></div></div></div><div id="rec281772601" class="r t-rec t-rec_pt_0 t-rec_pb_0 r_anim r_showed" style="padding-top:0px;padding-bottom:0px; " data-record-type="106"><!-- T004 --><div class="t004"><div class="t-container "> <div class="t-col t-col_10 t-prefix_1"><div field="text" class="t-text t-text_md " style="line-height:1.55;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Android динамично развивающаяся платформа. Именно Android поддерживает огромный интерес разработчиков к Java. Мотивируя начинающих программистов к изучению языка.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ниже будут представлены основные особенности рассматриваемой ОС:<br><br><ul><li>Открытый исходный код;</li><li>Сервисы Google и синхронизация;</li><li>Android API практически совпадает с Java API. Но, Android поддерживает не все классы, которые доступны в J2SE SDK. Он поддерживает только те, которые являются критичными.</li><li style="text-align: left;">Android не использует виртуальную машину Java для исполнения файлов классов. Android использует виртуальную машину Dalvik, которая не является JVM и не оперирует байт-кодом Java.</li><li>Dalvik - файлы классов компилируются в формат Dalvik Executable (DEX). После преобразования в DEX-формат, файлы классов вместе с остальными ресурсами обьединяются в Android Package (APK) для установки на различные гаджеты.</li></ul></div></div></div></div></div><div id="rec281774689" class="r t-rec t-rec_pt_30 t-rec_pb_30 r_anim r_showed" style="padding-top:30px;padding-bottom:30px; " data-record-type="127"><!-- T119 --><div class="t119"><div class="t-container "> <div class="t-col t-col_8 t-prefix_2"><div class="t119__preface t-descr" style="opacity:0.70;" field="text"><p style="text-align: center;"><strong>Архитектура операционной системы Android OS</strong></p></div></div></div></div></div><div id="rec281775527" class="r t-rec t-rec_pt_0 t-rec_pb_0 r_hidden r_anim" style="padding-top:0px;padding-bottom:0px; " data-record-type="106"><!-- T004 --><div class="t004"><div class="t-container "> <div class="t-col t-col_10 t-prefix_1"><div field="text" class="t-text t-text_md " style="line-height:1.55;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;При представлении компонентной модели Android в виде иерархии, в самом низу, будет располагаться ядро операционной системы. Известно, Android OS основан на ядре ОС Linux. Именно оно обеспечивает работу системы и отвечает за безопасность, управление памятью, энергосистемой и процессами, а также предоставляет сетевой стек и модель драйверов. Ядро обеспечивает взаимодействие между аппаратным обеспечением и программной частью.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Уровнем выше, расположен набор библиотек, предназначенный для обеспечения важнейшего базового функционала для приложений. Данный уровень отвечает за реализацию алгоритмов для вышележащих уровней, поддержку файловых форматов, осуществление кодирования и декодирования информации, прорисовку графики и многое другое. Библиотеки реализованы на C/C++ и скомпилированы под конкретное аппаратное обеспечение.</div></div></div></div></div><div id="rec281776675" class="r t-rec t-rec_pt_30 t-rec_pb_30 r_hidden r_anim" style="padding-top:30px;padding-bottom:30px; " data-record-type="127"><!-- T119 --><div class="t119"><div class="t-container "> <div class="t-col t-col_8 t-prefix_2"><div class="t119__preface t-descr" style="opacity:0.70;" field="text"><p style="text-align: center;"><strong>Обзор возможностей для хранения данных в ОС Android.</strong></p></div></div></div></div></div><div id="rec281777034" class="r t-rec t-rec_pt_0 t-rec_pb_0 r_hidden r_anim" style="padding-top:0px;padding-bottom:0px; " data-record-type="267"><!-- T232 --><div class="t232"><div class="t-container"> <div class="t-row"><div class="t-col t-col_10 t-prefix_1 t-align_left"> <div class="t232__titlebox" onclick="t232_expandtext(&#39;281777034&#39;);"><div class="t232__title t-name t-name_lg" style="" field="title"><p style="text-align: left;">Хранение пар ключ-значение</p></div></div></div></div> <div class="t-row"><div class="t-col t-col_10 t-prefix_1 t-align_left"> <div field="text" class="t232__text t-text t-text_sm" style="display: none;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Если необходим быстрый способ хранения нескольких строк или номеров, то следует рассмотреть возможность использования файла настроек (preferences). Activities и службы <em>Android</em> могут использовать метод <em>getDefaultSharedPreferences()</em> класса <em>PreferenceManager</em>, чтобы ссылаться на объект <em>SharedPreferences</em>, который может быть использован и для чтения, и для записи в файл настроек по умолчанию.<br><br><p style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em style="color: rgb(0, 0, 0);">SharedPreferences myPreferences</em></p><p style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em style="color: rgb(0, 0, 0);">= PreferenceManager.getDefaultSharedPreferences(MyActivity.</em><strong style="color: rgb(0, 102, 153);"><em>this</em></strong><em style="color: rgb(0, 0, 0);">);</em></p><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Чтобы начать запись в файл настроек, необходимо вызвать метод <em>edit() </em>объекта <em>SharedPreferences</em>, который возвращает объект <em>SharedPreferences.Editor.</em><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>SharedPreferences.Editor myEditor = myPreferences.edit();</em><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Объект <em>SharedPreferences.Editor</em> имеет несколько интуитивных методов, которые можно использовать для хранения новых пар ключ-значение в файле настроек. Например, можно использовать метод <em>putString()</em>, чтобы поместить пару ключ-значение со значением типа String. Аналогично, вы можете использовать метод <em>putFloat()</em>, чтобы поместить пару ключ-значение, чьё значение типа <em>float</em>.<br><br><p style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em style="color: rgb(0, 0, 0);">myEditor.putString(</em><em style="color: rgb(0, 0, 255);">"NAME"</em><em style="color: rgb(0, 0, 0);">, </em><em style="color: rgb(0, 0, 255);">"Alice"</em><em style="color: rgb(0, 0, 0);">);</em></p><p style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em style="color: rgb(0, 0, 0);">myEditor.putInt(</em><em style="color: rgb(0, 0, 255);">"AGE"</em><em style="color: rgb(0, 0, 0);">, </em><em style="color: rgb(0, 153, 0);">25</em><em style="color: rgb(0, 0, 0);">);</em></p><p style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em style="color: rgb(0, 0, 0);">myEditor.putBoolean(</em><em style="color: rgb(0, 0, 255);">"SINGLE?"</em><em style="color: rgb(0, 0, 0);">, </em><strong style="color: rgb(0, 102, 153);"><em>true</em></strong><em style="color: rgb(0, 0, 0);">);</em></p><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;После того, как были добавлены все пары, необходимо вызвать метод <em>commit()</em> объекта <em>SharedPreferences.Editor</em>, чтобы сохранить их.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>myEditor.commit();</em><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Чтение из объекта <em>SharedPreferences</em> гораздо проще. Всё, что нужно сделать, так это вызвать соответствующий метод <em>get*()</em>. Например, чтобы получить пару ключ-значение, чьё значение является String, необходимо вызывать метод <em>getString()</em>. Вот фрагмент кода, который извлекает все значения, которые мы добавили ранее:<br><br><p style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(0, 0, 0);">String name = myPreferences.getString(</span><span style="color: rgb(0, 0, 255);">"NAME"</span><span style="color: rgb(0, 0, 0);">, </span><span style="color: rgb(0, 0, 255);">"unknown"</span><span style="color: rgb(0, 0, 0);">);</span></p><p style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong style="color: rgb(0, 102, 153);">int</strong> <span style="color: rgb(0, 0, 0);">age = myPreferences.getInt(</span><span style="color: rgb(0, 0, 255);">"AGE"</span><span style="color: rgb(0, 0, 0);">, </span><span style="color: rgb(0, 153, 0);">0</span><span style="color: rgb(0, 0, 0);">);</span></p><p style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong style="color: rgb(0, 102, 153);">boolean</strong> <span style="color: rgb(0, 0, 0);">isSingle = myPreferences.getBoolean(</span><span style="color: rgb(0, 0, 255);">"SINGLE?"</span><span style="color: rgb(0, 0, 0);">, </span><strong style="color: rgb(0, 102, 153);">false</strong><span style="color: rgb(0, 0, 0);">);</span></p><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Как видно из кода выше, второй параметр всех методов <em>get*()</em> ожидает значение по умолчанию, которое является значением, которое должно быть возвращено, если ключ не существует и файле настроек.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Обратите внимание, что файлы настроек ограничены только строками и примитивными типами данных. Если необходимо сохранить более сложные типы данных или двоичные данные, нужно выбрать другой вариант хранения.</div></div></div> </div></div><script type="text/javascript"> $("#rec281777034").find(".t232__text").toggle();</script></div><div id="rec281780969" class="r t-rec t-rec_pt_0 t-rec_pb_0 r_hidden r_anim" style="padding-top:0px;padding-bottom:0px; " data-record-type="267"><!-- T232 --><div class="t232"><div class="t-container"> <div class="t-row"><div class="t-col t-col_10 t-prefix_1 t-align_left"> <div class="t232__titlebox" onclick="t232_expandtext(&#39;281780969&#39;);"><div class="t232__title t-name t-name_lg" style="" field="title">Использование внутреннего хранилища</div></div></div></div> <div class="t-row"><div class="t-col t-col_10 t-prefix_1 t-align_left"> <div field="text" class="t232__text t-text t-text_sm" style="display: none;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Каждое приложение Android имеет свой собственный внутренний каталог хранения, взаимодействующий с ним, в котором приложение может хранить текстовые и двоичные файлы. Файлы внутри этого каталога недоступны для пользователя или других приложений, установленных на устройстве пользователя. Они также автоматически удаляются, когда пользователь удаляет приложение.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Прежде чем использовать внутренний каталог хранилища, необходимо определить его местоположение. Для этого можно вызвать метод <em>getFilesDir()</em>, который доступен как для активити, так и для служб.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>File internalStorageDir = getFilesDir();</em><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Чтобы получить ссылку на файл внутри каталога, можно передать имя файла вместе с указанным вами расположением. Например, вот как получить ссылку на файл <strong>alice.csv</strong>:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>&nbsp;</em><em style="font-size: 16px; font-weight: 400; color: rgb(0, 0, 0); font-family: Arial;">File alice = </em><strong style="font-size: 16px; font-weight: 700; color: rgb(0, 102, 153); font-family: Arial;"><em>new</em></strong><em style="font-family: Arial; font-size: 16px;"> </em><em style="font-size: 16px; font-weight: 400; color: rgb(0, 0, 0); font-family: Arial;">File(internalStorageDir, </em><em style="font-size: 16px; font-weight: 400; color: rgb(0, 0, 255); font-family: Arial;">"alice.csv"</em><em style="font-size: 16px; font-weight: 400; color: rgb(0, 0, 0); font-family: Arial;">);</em><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В следующем фрагменте кода показано, как использовать объект<em> FileOutputStream</em> и метод <em>write()</em> для записи в файл:<br><br><p style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em style="color: rgb(0, 130, 0);">// Create file output stream</em></p><p style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em style="color: rgb(0, 0, 0);">fos = </em><strong style="color: rgb(0, 102, 153);"><em>new</em></strong><em> </em><em style="color: rgb(0, 0, 0);">FileOutputStream(alice);</em></p><p style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em style="color: rgb(0, 130, 0);">// Write a line to the file</em></p><p style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em style="color: rgb(0, 0, 0);">fos.write(</em><em style="color: rgb(0, 0, 255);">"Alice,25,1"</em><em style="color: rgb(0, 0, 0);">.getBytes());</em></p><p style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em style="color: rgb(0, 130, 0);">// Close the file output stream</em></p><p style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em style="color: rgb(0, 0, 0);">fos.close();</em></p></div></div></div> </div></div><script type="text/javascript"> $("#rec281780969").find(".t232__text").toggle();</script></div><div id="rec281781327" class="r t-rec t-rec_pt_0 t-rec_pb_0 r_hidden r_anim" style="padding-top:0px;padding-bottom:0px; " data-record-type="267"><!-- T232 --><div class="t232"><div class="t-container"> <div class="t-row"><div class="t-col t-col_10 t-prefix_1 t-align_left"> <div class="t232__titlebox" onclick="t232_expandtext(&#39;281781327&#39;);"><div class="t232__title t-name t-name_lg" style="" field="title">Использование внешнего хранилища</div></div></div></div> <div class="t-row"><div class="t-col t-col_10 t-prefix_1 t-align_left"> <div field="text" class="t232__text t-text t-text_sm" style="display: none;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Поскольку внутреннее хранилище устройств Android обычно фиксировано и часто довольно ограничено, некоторые устройства Android поддерживают внешние носители данных, такие как съемные микро SD-карты. Рекомендуется использовать этот вариант хранения для больших файлов, таких как фотографии и видео.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В отличие от внутреннего хранилища, внешнее хранилище может не всегда быть доступно. Поэтому, перед его использованием, необходимо всегда проверять, смонтировано ли оно. Для этого используется метод <em>getExternalStorageState()</em> класса <em>Environment</em>.<br><br><p style="text-align: left;"><em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em><strong style="color: rgb(0, 102, 153);"><em>if</em></strong><em style="color: rgb(0, 0, 0);">(Environment.getExternalStorageState()</em></p><p style="text-align: left;"><em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em><em style="color: rgb(0, 0, 0);">.equals(Environment.MEDIA_MOUNTED)) {</em></p><p style="text-align: left;"><em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em><em style="color: rgb(0, 130, 0);">// External storage is usable</em></p><p style="text-align: left;"><em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em><em style="color: rgb(0, 0, 0);">} </em><strong style="color: rgb(0, 102, 153);"><em>else</em></strong><em> </em><em style="color: rgb(0, 0, 0);">{</em></p><p style="text-align: left;"><em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em><em style="color: rgb(0, 130, 0);">// External storage is not usable</em></p><p style="text-align: left;"><em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em><em style="color: rgb(0, 130, 0);">// Try again later</em></p><p style="text-align: left;"><em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em><em style="color: rgb(0, 0, 0);">}</em></p><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Как только внешнее хранилище доступно, можно получить путь к файлу внешнего хранилища для своего приложения, вызвав метод <em>getExternalFilesDir()</em> и передав <em>null</em> в качестве аргумента. Затем можно использовать путь для ссылки на файлы внутри каталога. Например, вот как возможно ссылаться на файл с именем <strong>bob.jpg</strong> в каталоге внешнего хранилища приложения:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em style="color: rgb(0, 0, 0); font-weight: 400; font-size: 16px;">File bob = </em><strong style="color: rgb(0, 102, 153); font-weight: 700; font-size: 16px;"><em>new</em></strong><em style="font-size: 16px;"> </em><em style="color: rgb(0, 0, 0); font-weight: 400; font-size: 16px;">File(getExternalFilesDir(</em><strong style="color: rgb(0, 102, 153); font-weight: 700; font-size: 16px;"><em>null</em></strong><em style="color: rgb(0, 0, 0); font-weight: 400; font-size: 16px;">), </em><em style="color: rgb(0, 0, 255); font-weight: 400; font-size: 16px;">"bob.jpg"</em><em style="color: rgb(0, 0, 0); font-weight: 400; font-size: 16px;">);</em><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Попросив пользователя предоставить разрешение <em>WRITE_EXTERNAL_STORAGE</em>, возможно получить доступ для чтения/записи ко всей файловой системе во внешнем хранилище. Затем используются известные общедоступные каталоги для хранения фотографий, фильмов и других мультимедийных файлов. Класс <em>Environment</em> предлагает метод <em>getExternalStoragePublicDirectory()</em> для определения путей этих общих каталогов.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Вот как можно ссылаться на файл <strong>bob.jpg</strong> в каталоге общих изображений:<br><br><p style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>&nbsp;&nbsp;</em><em style="color: rgb(0, 0, 0);">File bobInPictures = </em><strong style="color: rgb(0, 102, 153);"><em>new</em></strong><em> </em><em style="color: rgb(0, 0, 0);">File(</em></p><p style="text-align: left;"><em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em><em style="color: rgb(0, 0, 0);">Environment.getExternalStoragePublicDirectory(</em></p><p style="text-align: left;"><em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em><em style="color: rgb(0, 0, 0);">Environment.DIRECTORY_PICTURES),</em></p><p style="text-align: left;"><em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em><em style="color: rgb(0, 0, 255);">"bob.jpg"</em></p><p style="text-align: left;"><em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em><em style="color: rgb(0, 0, 0);">);</em></p><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Когда есть объект <em>File</em>, можно снова использовать классы <em>FileInputStream</em> и <em>FileOutputStream</em> для чтения или записи на него.<br><br></div></div></div> </div></div><script type="text/javascript"> $("#rec281781327").find(".t232__text").toggle();</script></div><div id="rec281781562" class="r t-rec t-rec_pt_0 t-rec_pb_0 r_hidden r_anim" style="padding-top:0px;padding-bottom:0px; " data-record-type="267"><!-- T232 --><div class="t232"><div class="t-container"> <div class="t-row"><div class="t-col t-col_10 t-prefix_1 t-align_left"> <div class="t232__titlebox" onclick="t232_expandtext(&#39;281781562&#39;);"><div class="t232__title t-name t-name_lg" style="" field="title">Использование базы данных SQLite</div></div></div></div> <div class="t-row"><div class="t-col t-col_10 t-prefix_1 t-align_left"> <div field="text" class="t232__text t-text t-text_sm" style="display: none;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Каждое приложение для Android может создавать и использовать базы данных SQLite для хранения больших объемов структурированных данных. SQLite не только лёгкая, но и очень быстрая.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Чтобы создать новую базу данных SQLite или открыть уже существующую, используется метод <em>openOrCreateDatabase()</em> внутри своей активность или службы. В качестве аргументов необходимо передать имя своей базы данных и режим, в котором вы хотите её открыть. Наиболее часто используемый режим <em>MODE_PRIVATE</em>, который гарантирует, что база данных доступна только для данного приложения. Например, вот как возможно открыть или создать базу данных с именем <strong>my.db</strong>:<br><br><p style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em style="color: rgb(0, 0, 0);">SQLiteDatabase myDB = </em></p><p style="text-align: left;"><em>&nbsp;&nbsp;&nbsp;&nbsp;</em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em style="color: rgb(0, 0, 0);">openOrCreateDatabase(</em><em style="color: rgb(0, 0, 255);">"my.db"</em><em style="color: rgb(0, 0, 0);">, MODE_PRIVATE, </em><strong style="color: rgb(0, 102, 153);"><em>null</em></strong><em style="color: rgb(0, 0, 0);">);</em></p><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;После создания базы данных можно использовать метод <em>execSQL()</em> для запуска SQL-инструкций. В следующем коде показано, как использовать оператор <em>SQL CREATE TABLE</em> для создания таблицы названной <strong>user</strong>, которая имеет три столбца:<br><br><p style="text-align: left;"><em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em><em style="color: rgb(0, 0, 0);">myDB.execSQL(</em></p><p style="text-align: left;"><em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em><em style="color: rgb(0, 0, 255);">"CREATE TABLE IF NOT EXISTS user (name VARCHAR(200), age INT, is_single INT)"</em></p><p style="text-align: left;"><em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em><em style="color: rgb(0, 0, 0);">);</em></p><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Хотя можно вставить новые строки в таблицу с помощью метода <em>execSQL()</em>, лучше использовать метод <em>insert()</em>. Метод <em>insert()</em> ожидает объект <em>ContentValues</em>, содержащий значения для каждого столбца таблицы. Объект <em>ContentValues</em> очень похож на объект <em>Map</em> и содержит пары ключ-значение.<br><br><p style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em style="color: rgb(0, 0, 0);">ContentValues row1 = </em><strong style="color: rgb(0, 102, 153);"><em>new</em></strong><em> </em><em style="color: rgb(0, 0, 0);">ContentValues();</em></p><p style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em style="color: rgb(0, 0, 0);">row1.put(</em><em style="color: rgb(0, 0, 255);">"name"</em><em style="color: rgb(0, 0, 0);">, </em><em style="color: rgb(0, 0, 255);">"Alice"</em><em style="color: rgb(0, 0, 0);">);</em></p><p style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em style="color: rgb(0, 0, 0);">row1.put(</em><em style="color: rgb(0, 0, 255);">"age"</em><em style="color: rgb(0, 0, 0);">, </em><em style="color: rgb(0, 153, 0);">25</em><em style="color: rgb(0, 0, 0);">);</em></p><p style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em style="color: rgb(0, 0, 0);">row1.put(</em><em style="color: rgb(0, 0, 255);">"is_single"</em><em style="color: rgb(0, 0, 0);">, </em><em style="color: rgb(0, 153, 0);">1</em><em style="color: rgb(0, 0, 0);">);</em></p><p style="text-align: left;"><em>&nbsp;</em></p><p style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em style="color: rgb(0, 0, 0);">ContentValues row2 = </em><strong style="color: rgb(0, 102, 153);"><em>new</em></strong><em> </em><em style="color: rgb(0, 0, 0);">ContentValues();</em></p><p style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em style="color: rgb(0, 0, 0);">row2.put(</em><em style="color: rgb(0, 0, 255);">"name"</em><em style="color: rgb(0, 0, 0);">, </em><em style="color: rgb(0, 0, 255);">"Bob"</em><em style="color: rgb(0, 0, 0);">);</em></p><p style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em style="color: rgb(0, 0, 0);">row2.put(</em><em style="color: rgb(0, 0, 255);">"age"</em><em style="color: rgb(0, 0, 0);">, </em><em style="color: rgb(0, 153, 0);">20</em><em style="color: rgb(0, 0, 0);">);</em></p><p style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em style="color: rgb(0, 0, 0);">row2.put(</em><em style="color: rgb(0, 0, 255);">"is_single"</em><em style="color: rgb(0, 0, 0);">, </em><em style="color: rgb(0, 153, 0);">0</em><em style="color: rgb(0, 0, 0);">);</em></p><br><br><br><br>&nbsp; &nbsp; &nbsp; &nbsp; Ключи, которые передаются методу <em>put()</em>, должны соответствовать именам столбцов в таблице. Когда объекты <em>ContentValues</em> готовы, вы можете передать их методу <em>insert()</em> вместе с именем таблицы.<br><br><p style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em style="color: rgb(0, 0, 0);">myDB.insert(</em><em style="color: rgb(0, 0, 255);">"user"</em><em style="color: rgb(0, 0, 0);">, </em><strong style="color: rgb(0, 102, 153);"><em>null</em></strong><em style="color: rgb(0, 0, 0);">, row1);</em></p><p style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em style="color: rgb(0, 0, 0);">myDB.insert(</em><em style="color: rgb(0, 0, 255);">"user"</em><em style="color: rgb(0, 0, 0);">, </em><strong style="color: rgb(0, 102, 153);"><em>null</em></strong><em style="color: rgb(0, 0, 0);">, row2);</em></p><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Чтобы отправить запрос в базу данных, можно использовать метод <em>rawQuery()</em>, который возвращает объект <em>Cursor</em>, содержащий результаты запроса.<br><br><p style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em style="color: rgb(0, 0, 0);">Cursor myCursor = </em></p><p style="text-align: left;"><em>&nbsp;&nbsp;&nbsp;&nbsp;</em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em style="color: rgb(0, 0, 0);">myDB.rawQuery(</em><em style="color: rgb(0, 0, 255);">"select name, age, is_single from user"</em><em style="color: rgb(0, 0, 0);">, </em><strong style="color: rgb(0, 102, 153);"><em>null</em></strong><em style="color: rgb(0, 0, 0);">);</em></p><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Объект <em>Cursor</em> может содержать ноль или несколько строк. Самый простой способ перебрать все его строки, так это вызвать метод <em>moveToNext()</em> внутри цикла <em>while</em>. Чтобы получить значение отдельного столбца, необходимо использовать такие методы, как <em>getString()</em> и <em>getInt()</em>, которые ожидают индекс столбца. Например, вот как возможно получите все значения, вставленные в таблице<em> user</em>:<br><br><p style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong style="color: rgb(0, 102, 153);"><em>while</em></strong><em style="color: rgb(0, 0, 0);">(myCursor.moveToNext()) {</em></p><p style="text-align: left;"><em>&nbsp;&nbsp;&nbsp;&nbsp;</em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em style="color: rgb(0, 0, 0);">String name = myCursor.getString(</em><em style="color: rgb(0, 153, 0);">0</em><em style="color: rgb(0, 0, 0);">);</em></p><p style="text-align: left;"><em>&nbsp;&nbsp;&nbsp;&nbsp;</em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong style="color: rgb(0, 102, 153);"><em>int</em></strong><em> </em><em style="color: rgb(0, 0, 0);">age = myCursor.getInt(</em><em style="color: rgb(0, 153, 0);">1</em><em style="color: rgb(0, 0, 0);">);</em></p><p style="text-align: left;"><em>&nbsp;&nbsp;&nbsp;&nbsp;</em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong style="color: rgb(0, 102, 153);"><em>boolean</em></strong><em> </em><em style="color: rgb(0, 0, 0);">isSingle = (myCursor.getInt(</em><em style="color: rgb(0, 153, 0);">2</em><em style="color: rgb(0, 0, 0);">)) == </em><em style="color: rgb(0, 153, 0);">1</em><em> </em><em style="color: rgb(0, 0, 0);">? </em><strong style="color: rgb(0, 102, 153);"><em>true</em></strong><em style="color: rgb(0, 0, 0);">:</em><strong style="color: rgb(0, 102, 153);"><em>false</em></strong><em style="color: rgb(0, 0, 0);">;</em></p><p style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em style="color: rgb(0, 0, 0);">}</em></p><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;После того, как вы получите все результаты вашего запроса, убедитесь, что вы вызвали метод <em>close()</em> для объекта <em>Cursor</em>, чтобы освободить все ресурсы, которые он хранит.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>myCursor.close();</em><br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Аналогичным образом, когда вы закончили все операции с базой данных, не забудьте вызвать метод <em>close()</em> для объекта <em>SQLiteDatabase</em>.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>myDB.close();</em></div></div></div> </div></div><script type="text/javascript"> $("#rec281781562").find(".t232__text").toggle();</script></div><div id="rec281781803" class="r t-rec t-rec_pt_30 t-rec_pb_30 r_hidden r_anim" style="padding-top:30px;padding-bottom:30px; " data-record-type="127"><!-- T119 --><div class="t119"><div class="t-container "> <div class="t-col t-col_8 t-prefix_2"><div class="t119__preface t-descr" style="opacity:0.70;" field="text"><p style="text-align: center;"><strong>SQLite - Типы данных</strong></p></div></div></div></div></div><div id="rec281781985" class="r t-rec t-rec_pt_0 t-rec_pb_0 r_hidden r_anim" style="padding-top:0px;padding-bottom:0px; " data-record-type="106"><!-- T004 --><div class="t004"><div class="t-container "> <div class="t-col t-col_10 t-prefix_1"><div field="text" class="t-text t-text_md " style="line-height:1.55;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Тип данных SQLite - это атрибут, определяющий тип данных любого объекта. Каждый столбец, переменная и выражение имеет связанный тип данных в SQLite.<br>Вы будете использовать эти типы данных при создании своих таблиц. SQLite использует более общую систему динамического типа. В SQLite тип данных значения связан с самим значением, а не с его контейнером.<br><br><strong>Классы хранения SQLite</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Каждое значение, хранящееся в базе данных SQLite, имеет один из следующих классов хранения<br><br><br><strong>﻿NULL</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Значение - значение NULL.<br><strong>INTEGER</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Значение представляет собой целое число со знаком, сохраненное в 1, 2, 3, 4, 6 или 8 байтах в зависимости от величины значения.<br><strong>REAL</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Значение представляет собой значение с плавающей запятой, которое хранится как 8-байтовое число с плавающей точкой IEEE.<br><strong>TEXT</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Значение представляет собой текстовую строку, хранящуюся с использованием кодировки базы данных (UTF-8, UTF-16BE или UTF-16LE)<br><strong>BLOB</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Значение представляет собой блок данных, который хранится точно так же, как он был введен.<br><br><br><br><strong>Тип слияния SQLite</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SQLite поддерживает концепцию affinity (близость) типа к столбцам. Любой столбец может хранить данные любого типа, но предпочтительный класс хранения для столбца называется affinity. Каждому столбцу таблицы в базе данных SQLite3 присваивается одно из следующих аффинностей типа:<br><br><br><strong>TEXT</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В этом столбце хранятся все данные с использованием классов хранения NULL, TEXT или BLOB.<br><strong>NUMERIC</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Этот столбец может содержать значения, используя все пять классов хранения.<br><strong>INTEGER</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Работает так же, как столбец с NUMERIC сродством, с исключением в выражении CAST.<br><strong>REAL</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ведет себя как столбец с NUMERIC сродством, за исключением того, что он приводит целые значения в представление с плавающей запятой.<br><strong>NONE</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Столбец с аффинностью NONE не предпочитает один класс хранения над другим, и не предпринимаются попытки принудить данные из одного класса хранения к другому.<br><br><br><strong>Boolean </strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SQLite не имеет отдельного булевского класса хранения. Вместо этого значения сохраняются как целые числа 0 (ложь) и 1 (истина).<br><br><br><strong> Тип данных даты и времени</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SQLite не имеет отдельного класса хранения для хранения дат и / или времени, но SQLite способен хранить даты и время как значения TEXT, REAL или INTEGER.<br><br><br><br><strong>TEXT</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Дата в формате "YYYY-MM-DD HH:MM:SS.SSS"<br><strong>REAL</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Число дней с полудня в Гринвиче 24 ноября 4714 г. до н.э.<br><strong>INTEGER</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Количество секунд с 1970-01-01 00:00:00 UTC</div></div></div></div></div><div id="rec281783706" class="r t-rec t-rec_pt_30 t-rec_pb_30 r_hidden r_anim" style="padding-top:30px;padding-bottom:30px; " data-record-type="127"><!-- T119 --><div class="t119"><div class="t-container "> <div class="t-col t-col_8 t-prefix_2"><div class="t119__preface t-descr" style="opacity:0.70;" field="text"><p style="text-align: center;"><strong>Адаптеры</strong></p></div></div></div></div></div><div id="rec281783732" class="r t-rec t-rec_pt_0 t-rec_pb_0 r_hidden r_anim" style="padding-top:0px;padding-bottom:0px; " data-record-type="106"><!-- T004 --><div class="t004"><div class="t-container "> <div class="t-col t-col_10 t-prefix_1"><div field="text" class="t-text t-text_md " style="line-height:1.55;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В Android часто используются адаптеры. Если говорить в общих чертах, то адаптеры упрощают связывание данных с элементом управления. Адаптеры используются при работе с виджетами, которые дополняют <strong>android.widget.AdapterView</strong>: <strong>ListView</strong>, <strong>ExpandableListView</strong>, <strong>GridView</strong>, <strong>Spinner</strong>, <strong>Gallery</strong>, а также в активности <strong>ListActivity</strong> и др. Сам <strong>AdapterView</strong> дополняет <strong>android.widget.ViewGroup</strong>.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Итак, у нас есть набор объектов и есть компонент <strong>View</strong>. Назначение адаптера заключается в том, чтобы предоставлять дочерние виды для контейнера. Адаптер берет данные и метаданные определенного контейнера и строит каждый дочерний вид. Например, мы формируем пункты списка (массив строк) и передаём его списку <strong>ListView</strong>.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В приложениях очень часто используется список на основе <strong>ListView</strong>. Сам список состоит из множества элементов <strong>TextView</strong>, которые идут друг за другом. Но их количество будет зависеть от того, чтобы мы хотим отобразить. Если нам нужны дни недели, то достаточно семи элементов, если месяцы, то уже двенадцать. Короче говоря, нам нужно составить данные, например, в виде массива и скормить его списку. Адаптер этим и занимается. Он берёт по порядку предоставленные данные и размещает их в списке по порядку. При этом адаптер на лету создаёт нужные компоненты <strong>TextView</strong> и помещает в него приготовленный текст. Данные могут быть находиться не только в массиве, но и в базе данных. Для такого случая используется другой адаптер. А также вы можете придумать свой адаптер. Существуют уже готовые адаптеры на самые распространённые случаи и их предназначение можно определить по именам. Например, <strong>ArrayAdapter</strong> использует массив, а <strong>CursorAdapter</strong> работает с объектом <strong>Cursor</strong>, используемый в базах данных.<br><br></div></div></div></div></div><div id="rec281784602" class="r t-rec t-rec_pt_0 t-rec_pb_0 r_hidden r_anim" style="padding-top:0px;padding-bottom:0px; " data-record-type="267"><!-- T232 --><div class="t232"><div class="t-container"> <div class="t-row"><div class="t-col t-col_10 t-prefix_1 t-align_left"> <div class="t232__titlebox" onclick="t232_expandtext(&#39;281784602&#39;);"><div class="t232__title t-name t-name_lg" style="" field="title"><strong>Готовые адаптеры</strong></div></div></div></div> <div class="t-row"><div class="t-col t-col_10 t-prefix_1 t-align_left"> <div field="text" class="t232__text t-text t-text_sm" style="display: none;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Все адаптеры, содержащиеся в Android, дополняют базовый адаптер BaseAdapter. Вот список готовых адаптеров:<br><br><ul><li><strong>ArrayAdapter</strong>&lt;T&gt; - предназначен для работы с <strong>ListView</strong>. Данные представлены в виде массива, которые размещаются в отдельных элементах <strong>TextView</strong></li><li><strong>ListAdapter</strong> - адаптер между <strong>ListView</strong> и данными. Строго говоря, это класс-интерфейс, который можно использовать и в <strong>ArrayAdapter</strong> и в <strong>SimpleAdapter </strong>и т.д.</li><li><strong>SpinnerAdapter</strong> - адаптер для связки данных с элементом <strong>Spinner</strong>. Это тоже интерфейс, как <strong>ListAdapter</strong> и работает по схожему принципу</li><li><strong>SimpleAdapter</strong> - адаптер, позволяющий заполнить данными список более сложной структуры, например, два текста в одной строке списка.</li><li><strong>SimpleCursorAdapter</strong> - дополняет <strong>ResourceCursorAdapter</strong> и создаёт компоненты <strong>TextView/ImageView </strong>из столбцов, содержащихся в курсоре. Компоненты определяются в ресурсах</li><li><strong>CursorAdapter</strong> - предназначен для работы с <strong>ListView</strong>, предоставляет данные для списка через курсор, который должен иметь колонку с именем "_id"</li><li><strong>ResourceCursorAdapter</strong> - этот адаптер дополняет <strong>CursorAdapter</strong> и может создавать виды из ресурсов</li><li><strong>HeaderViewListAdapter</strong> - расширенный вариант <strong>ListAdapter</strong>, когда <strong>ListView</strong> имеет заголовки.</li><li><strong>WrapperListAdapter</strong> - еще один адаптер для списков.</li></ul></div></div></div> </div></div><script type="text/javascript"> $("#rec281784602").find(".t232__text").toggle();</script></div><div id="rec281784890" class="r t-rec t-rec_pt_0 t-rec_pb_0 r_hidden r_anim" style="padding-top:0px;padding-bottom:0px; " data-record-type="267"><!-- T232 --><div class="t232"><div class="t-container"> <div class="t-row"><div class="t-col t-col_10 t-prefix_1 t-align_left"> <div class="t232__titlebox" onclick="t232_expandtext(&#39;281784890&#39;);"><div class="t232__title t-name t-name_lg" style="" field="title"><strong>BaseAdapter</strong></div></div></div></div> <div class="t-row"><div class="t-col t-col_10 t-prefix_1 t-align_left"> <div field="text" class="t232__text t-text t-text_sm" style="display: none;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Стандартные адаптеры не всегда покрывают потребности программиста. Если необходим свой собственный адаптер, то в Android есть абстрактный класс BaseAdapter, который можно расширить. Собственный адаптер необходим в тех случаях, когда требуется специальное управление данными или дополнительный контроль над отображением дочерних представлений. Кроме того, вы можете предусмотреть в своём адаптере элементы кэширования для повышения производительности работы.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;У <strong>BaseAdapter</strong> есть несколько методов, которые следует переопределить. Например, метод <strong>getCount</strong>() позволяет узнать количество выводимых объектов.<br>Другой важный метод адаптера — <strong>getView</strong>(), который отвечает за создание отдельных элементов списка. Он вызывается для каждого элемента списка, чтобы определить, какие данные нужно отобразить. Метод <strong>getVew</strong>() содержит параметр <strong>convertView</strong>, который позволяет использовать заново уже существующий элемент списка, который не отображается, т.к. пользователь пролистнул его с видимой части дисплея. Если <strong>convertView</strong> не пустой, он может быть использован заново, чтобы не грузить разметку списка. Подобный подход способствует увеличению производительности.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Метод <strong>getView</strong>() возвращает <strong>View</strong>, который фактически является контейнером <strong>ViewGroup</strong> и содержит в себе другие компоненты, например, <strong>ImageView</strong> или <strong>TextView</strong>.</div></div></div> </div></div><script type="text/javascript"> $("#rec281784890").find(".t232__text").toggle();</script></div><div id="rec281785111" class="r t-rec t-rec_pt_30 t-rec_pb_30 r_hidden r_anim" style="padding-top:30px;padding-bottom:30px; " data-record-type="127"><!-- T119 --><div class="t119"><div class="t-container "> <div class="t-col t-col_8 t-prefix_2"><div class="t119__preface t-descr" style="opacity:0.70;" field="text"><p style="text-align: center;"><strong>Компонент ContentProvider</strong></p></div></div></div></div></div><div id="rec281785186" class="r t-rec t-rec_pt_0 t-rec_pb_0 r_hidden r_anim" style="padding-top:0px;padding-bottom:0px; " data-record-type="106"><!-- T004 --><div class="t004"><div class="t-container "> <div class="t-col t-col_10 t-prefix_1"><div field="text" class="t-text t-text_md " style="line-height:1.55;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Контент-провайдер или "Поставщик содержимого" (Content Provider) - это оболочка (wrapper), в которую заключены данные. Если ваше приложение использует базу данных SQLite, то только ваше приложение имеет к ней доступ. Но бывают ситуации, когда данные желательно сделать общими. Простой пример - ваши контакты из телефонной книги тоже содержатся в базе данных, но вы хотите иметь доступ к данным, чтобы ваше приложение тоже могло выводить список контактов. Так как вы не имеете доступа к базе данных чужого приложения, был придуман специальный механизм, позволяющий делиться своими данными всем желающим.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Поставщик содержимого применяется лишь в тех случаях, когда вы хотите использовать данные совместно с другими приложениями, работающих в устройстве. Но даже если вы не планируете сейчас делиться данными, то всё-равно можно подумать об реализации этого способа на всякий случай.</div></div></div></div></div><div id="rec281785434" class="r t-rec t-rec_pt_0 t-rec_pb_0 r_hidden r_anim" style="padding-top:0px;padding-bottom:0px; " data-record-type="3"><!-- T107 --><div class="t107"> <div class="t-align_center" itemscope="" itemtype="http://schema.org/ImageObject"><meta itemprop="image" content="https://static.tildacdn.com/tild6233-3638-4461-b832-343762373336/srtgwer.png"> <img src="./ТОП ДОКЛАД ИН ЗЕ ВОРД_files/srtgwer.png" data-original="https://static.tildacdn.com/tild6233-3638-4461-b832-343762373336/srtgwer.png" class="t107__widthauto t-img" imgfield="img"> </div> </div></div><div id="rec281785611" class="r t-rec t-rec_pt_0 t-rec_pb_0 r_hidden r_anim" style="padding-top:0px;padding-bottom:0px; " data-record-type="106"><!-- T004 --><div class="t004"><div class="t-container "> <div class="t-col t-col_10 t-prefix_1"><div field="text" class="t-text t-text_md " style="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В Android существует возможность выражения источников данных (или поставщиков данных) при помощи передачи состояния представления - REST, в виде абстракций, называемых поставщиками содержимого. Базу данных SQLite можно заключить в поставщик содержимого. Чтобы получить данные из поставщика содержимого или сохранить в нём новую информацию, нужно использовать набор REST-подобных идентификаторов URI. Например, если бы вам было нужно получить набор книг из поставщика содержимого, в котором заключена электронная библиотека, вам понадобился бы такой URI (по сути запрос к получению всех записей таблицы books):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>&nbsp;content://com.android.book.bookprovider/books</em><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Чтобы получить из библиотеки конкретную книгу (например, книгу №23), будет использоваться следующий URI (отдельный ряд таблицы):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>content://com.android.book.bookProvider/books/23</em><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Любая программа, работающая в устройстве, может использовать такие URI для доступа к данным и осуществления с ними определенных операций. Следовательно, поставщики содержимого играют важную роль при совместном использовании данных несколькими приложениями.<br><br></div></div></div></div></div><div id="rec281786523" class="r t-rec t-rec_pt_30 t-rec_pb_30 r_hidden r_anim" style="padding-top:30px;padding-bottom:30px; " data-record-type="127"><!-- T119 --><div class="t119"><div class="t-container "> <div class="t-col t-col_8 t-prefix_2"><div class="t119__preface t-descr" style="opacity:0.70;" field="text"><p style="text-align: center;"><strong>Механизм URI</strong></p></div></div></div></div></div><div id="rec281786630" class="r t-rec t-rec_pt_0 t-rec_pb_0 r_hidden r_anim" style="padding-top:0px;padding-bottom:0px; " data-record-type="106"><!-- T004 --><div class="t004"><div class="t-container "> <div class="t-col t-col_10 t-prefix_1"><div field="text" class="t-text t-text_md " style="line-height:1.55;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Для получения данных из поставщика содержимого нужно просто активировать URI. Однако при работе с поставщиком содержимого найденные таким образом данные представлены как набор строк и столбцов и образуют объект Android <strong>cursor</strong>. Рассмотрим структуру URI, которую можно использовать для получения данных.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Унифицированные идентификаторы содержимого (Content URI) в Android напоминают HTTP URI, но начинаются с <strong>content</strong> и строятся по следующему образцу:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>content://*/*/*</em><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;или<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>content://authority-name/path-segment1/path-segment2/etc...</em><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Вот пример URI, при помощи которого в базе данных идентифицируется запись, имеющая номер 23:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>content://ru.name.provider.notepad/notes/23</em><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;После <strong>content:</strong> в URI содержится унифицированный идентификатор источника, который используется для нахождения поставщика содержимого в соответствующем реестре. Часть URI <strong>ru.name.provider.notepad</strong> представляет собой источник.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>/notes/23</strong> - это раздел пути (path section), специфичный для каждого отдельного поставщика содержимого. Фрагменты <strong>notes</strong> и <strong>23</strong> раздела пути называются сегментами пути (path segments). Одной из функций поставщика содержимого является документирование и интерпретация раздела и сегментов пути, содержащихся в URI.<br><br></div></div></div></div></div><div id="rec281786924" class="r t-rec t-rec_pt_30 t-rec_pb_30 r_hidden r_anim" style="padding-top:30px;padding-bottom:30px; " data-record-type="127"><!-- T119 --><div class="t119"><div class="t-container "> <div class="t-col t-col_8 t-prefix_2"><div class="t119__preface t-descr" style="opacity:0.70;" field="text"><p style="text-align: center;"><strong>Создание собственного контент-провайдера</strong></p></div></div></div></div></div><div id="rec281786977" class="r t-rec t-rec_pt_0 t-rec_pb_0 r_hidden r_anim" style="padding-top:0px;padding-bottom:0px; " data-record-type="106"><!-- T004 --><div class="t004"><div class="t-container "> <div class="t-col t-col_10 t-prefix_1"><div field="text" class="t-text t-text_md " style="line-height:1.55;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Для создания собственного контент-провайдера нужно унаследоваться от абстрактного класса <strong>ContentProvider</strong>:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>public class MyContentProvider extends ContentProvider {}</em><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В классе необходимо реализовать абстрактные методы <strong>query()</strong>, <strong>insert()</strong>, <strong>update()</strong>, <strong>delete()</strong>, <strong>getType()</strong>, <strong>onCreate()</strong>. Прослеживается некоторое сходство с созданием обычной базы данных.<br>А также его следует зарегистрировать в манифесте с помощью тега <strong>provider</strong> с атрибутами <strong>name</strong> и <strong>authorities</strong>. Тег <strong>authorities</strong> служит для описания базового пути URI, по которому <strong>ContentResolver</strong> может найти базу данных для взаимодействия. Данный тег должен быть уникальным, поэтому рекомендуется использовать имя вашего пакета, чтобы не произошло путаницы с другими приложениями, например:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>&lt;provider </em><br><em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;android:name:".MyContentProvider"</em><br><em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;android:authorities="ru.alexanderklimov.provider.notepad" /&gt;</em><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Источник поставщика содержимого аналогичен доменному имени сайта. Если источник уже зарегистрирован, эти поставщики содержимого будут представлены гиперссылками, начинающимися с соответствующего префикса источника:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>content://ru.alexanderklimov.provider.notepad/</em><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Итак, поставщики содержимого, как и веб-сайты, имеют базовое доменное имя, действующее как стартовая URL-страница.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Необходимо отметить, что поставщики содержимого, используемые в Android, могут иметь неполное имя источника. Полное имя источника рекомендуется использовать только со сторонними поставщиками содержимого. Поэтому вам иногда могут встретиться поставщики содержимого, состоящие из одного слова, например <strong>contacts</strong>, в то время как полное имя такого поставщика содержимого - <strong>com.google.android.contacts</strong>.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В поставщиках содержимого также встречаются REST-подобные гиперссылки, предназначенные для поиска данных и работы с ними. В случае описанной выше регистрации унифицированный идентификатор ресурса, предназначенный для обозначения каталога или коллекции записей в базе данных NotePadProvider, будет иметь имя:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>content://ru.alexanderklimov.provider.notepad/notes</em><br><br>URI для идентификации отдельно взятой записи будет иметь вид:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>content://ru.alexanderklimov.provider.notepad/notes/#</em><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Символ <strong>#</strong> соответствует конкретной записи (ряд таблицы). Ниже приведено еще несколько примеров URI, которые могут присутствовать в поставщиках содержимого:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>content://media/internal/images </em><br><em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;content://media/external/images </em><br><em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;content://contacts/people/ </em><br><em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;content://contacts/people/23</em><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Обратите внимание - здесь поставщики содержимого <strong>content://media</strong> и <strong>content://contacts</strong> имеют неполную структуру. Это обусловлено тем, что данные поставщики содержимого не являются сторонними и контролируются Android.</div></script></body></html>